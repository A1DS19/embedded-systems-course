=============================================================================
STATIC FUNCTIONS IN C++
=============================================================================

Static functions have TWO different meanings depending on where they are:

1. STATIC MEMBER FUNCTIONS (in classes)
2. STATIC FREE FUNCTIONS (in .cpp files)


=============================================================================
1. STATIC MEMBER FUNCTIONS (in classes)
=============================================================================

class Math {
public:
    // STATIC - No object needed
    static int add(int a, int b) {
        return a + b;
    }

    // NON-STATIC - Needs object
    int multiply(int a, int b) {
        return a * b * multiplier;  // Can access member variables
    }

private:
    int multiplier = 2;  // Member variable
};

// USAGE:
int result = Math::add(5, 10);  // ✓ Call with ClassName::
// NO object needed!

Math m;
int result2 = m.multiply(5, 10);  // ✗ Needs object

CHARACTERISTICS:
  ✓ Called on the CLASS, not an object (ClassName::functionName)
  ✗ NO access to non-static member variables
  ✗ NO 'this' pointer
  ✓ Can access static member variables
  ✓ Can be combined with constexpr, noexcept, [[nodiscard]]

WHEN TO USE:
  • Utility functions that don't need object state
  • Factory methods
  • Helper functions related to the class
  • Mathematical/conversion functions


=============================================================================
2. STATIC FREE FUNCTIONS (in .cpp files)
=============================================================================

// In utils.cpp

// STATIC free function - ONLY visible in THIS file
static int helperFunction() {
    return 42;
}

// NON-STATIC - visible to other files (if declared in header)
int publicFunction() {
    return helperFunction();  // ✓ Can use within same file
}

CHARACTERISTICS:
  • Internal linkage (private to the .cpp file)
  • Other .cpp files can't see it (even with extern)
  • Not exported by the linker
  • Each .cpp can have its own static function with the same name

WHEN TO USE:
  • Private helper functions for one .cpp file
  • Implementation details you don't want to expose
  • Avoid name collisions across files

MODERN ALTERNATIVE (C++11+):
Instead of static free functions, use anonymous namespaces:

namespace {
    int helperFunction() {  // Internal linkage
        return 42;
    }
}


=============================================================================
EXAMPLES
=============================================================================

// ===== STATIC MEMBER FUNCTIONS =====

class BitManipulation {
public:
    static constexpr uint8_t setBit(uint8_t byte, uint8_t bit) noexcept {
        return byte | (1 << bit);
    }

    static constexpr uint8_t clearBit(uint8_t byte, uint8_t bit) noexcept {
        return byte & ~(1 << bit);
    }
};

// Usage - no object needed!
uint8_t result = BitManipulation::setBit(0b00000000, 3);
// result = 0b00001000


// ===== ARDUINO-STYLE STATIC UTILITIES =====

class Arduino {
public:
    // Map value from one range to another
    static constexpr uint32_t map(uint32_t x,
                                  uint32_t in_min, uint32_t in_max,
                                  uint32_t out_min, uint32_t out_max) noexcept {
        return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    }

    static constexpr uint8_t LED_PIN = 13;
};

// Usage
uint32_t pwm = Arduino::map(512, 0, 1023, 0, 255);  // Map sensor to PWM


// ===== STATIC FREE FUNCTIONS (in .cpp) =====

// In sensor.cpp
static float convertToVoltage(int reading) {
    return reading * 5.0f / 1023.0f;
}

// Only functions in sensor.cpp can call convertToVoltage
// Other .cpp files can't see it!


=============================================================================
COMBINING STATIC WITH OTHER KEYWORDS
=============================================================================

class Utils {
public:
    // static + constexpr + noexcept
    static constexpr int square(int x) noexcept {
        return x * x;
    }

    // static + [[nodiscard]]
    [[nodiscard]] static bool validate(int value) {
        return value >= 0 && value <= 100;
    }

    // static + inline (redundant in class)
    static inline int add(int a, int b) {
        return a + b;
    }
};

// All work together!
constexpr int sq = Utils::square(5);  // Compile-time


=============================================================================
STATIC vs NON-STATIC MEMBER FUNCTIONS
=============================================================================

class Counter {
private:
    int count = 0;
    static int totalInstances;

public:
    // NON-STATIC - has access to 'count' and 'this'
    void increment() {
        count++;        // ✓ Access member variable
        totalInstances++; // ✓ Access static variable
    }

    // STATIC - NO access to 'count' or 'this'
    static void reset() {
        // count = 0;       // ✗ ERROR: Can't access member variable
        totalInstances = 0; // ✓ Can access static variable
    }

    // NON-STATIC getter
    int getCount() const {
        return count;  // ✓ Access member variable
    }

    // STATIC getter
    static int getTotalInstances() {
        return totalInstances;  // ✓ Access static variable
    }
};

// Usage
Counter c1, c2;
c1.increment();           // Non-static: needs object
Counter::reset();         // Static: no object needed
int total = Counter::getTotalInstances();  // Static


=============================================================================
REAL-WORLD MICROCONTROLLER EXAMPLES
=============================================================================

// 1. Hardware utilities
class Hardware {
public:
    static constexpr uint8_t digitalPinToBitMask(uint8_t pin) noexcept {
        return (1 << pin);
    }

    static constexpr uint8_t lowByte(uint16_t word) noexcept {
        return word & 0xFF;
    }

    static constexpr uint8_t highByte(uint16_t word) noexcept {
        return word >> 8;
    }
};

// 2. Timer calculations
class Timer {
public:
    static constexpr uint32_t usToTicks(uint32_t us, uint32_t freq) noexcept {
        return (us * freq) / 1000000;
    }

    static constexpr uint32_t ticksToUs(uint32_t ticks, uint32_t freq) noexcept {
        return (ticks * 1000000) / freq;
    }
};

// Usage - no Timer object needed
uint32_t ticks = Timer::usToTicks(1000, 16000000);  // 1ms at 16MHz


=============================================================================
SUMMARY
=============================================================================

STATIC MEMBER FUNCTIONS:
  • No object needed (ClassName::function())
  • No access to non-static members
  • Perfect for utilities, factories, helpers
  • Can combine with constexpr, noexcept, etc.

STATIC FREE FUNCTIONS:
  • Internal linkage (file-private)
  • Hidden from other .cpp files
  • Good for private helpers
  • Modern alternative: anonymous namespace

COMMON COMBINATIONS:
  • static constexpr noexcept → Compile-time utilities
  • static [[nodiscard]] → Important calculations
  • static inline → Small utilities (inline is redundant in classes)

MICROCONTROLLER BENEFITS:
  • No object overhead (no 'this' pointer)
  • Can be constexpr (compile-time evaluation)
  • Clean API (namespaced utilities)
  • No runtime cost for object creation

=============================================================================
